#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# Switch between git worktrees with speed.

args=("$@")
VERSION="0.2.8-fork"
BINARY_PATH=$(realpath "$0")
CHANGE_DIRECTORY_PREFIX="changedir:"

is_interactive=false

for arg in "${args[@]}"; do
	if [[ "$arg" == "-i" ]]; then
		if command -v fzf &> /dev/null
		then is_interactive=true
		else
			echo "Error: fzf is not installed for interactive mode"
			echo "Install from: https://github.com/junegunn/fzf#installation"
			exit 1
		fi
	break
	fi
done

# Lists all git worktree names (basenames only)
# Output: One worktree name per line
worktree_list_names() {
	if git rev-parse --git-dir &> /dev/null; then
		git worktree list --porcelain \
			| awk '/^worktree / {
				sub("worktree ", "");
				n = split($0, parts, "/");
				print parts[n]
			}'
	fi
}

# Creates a new git worktree with optional source branch
# Args:
#   $1 (worktree_name): Name for the new worktree and directory
#   $2 (source_branch): Optional source branch/tag/commit (defaults to current branch)
# Usage: wt add <name> [source]
add_worktree() {
	local worktree_name="${args[1]:-}"
	local source_branch="${args[2]:-}"
	local worktree_path
	local repo_root

	# Validate worktree name
	if [[ -z "$worktree_name" ]]; then
		echo "Error: worktree name is required" >&2
		echo "Usage: wt add <worktree-name> [source-branch]" >&2
		exit 1
	fi

	# Prevent path traversal attacks
	if [[ "$worktree_name" =~ [./] ]]; then
		echo "Error: worktree name cannot contain '.', '/', or path separators" >&2
		exit 1
	fi

	# Check git repository
	if ! git rev-parse --git-dir &> /dev/null; then
		echo "Error: not in a git repository" >&2
		exit 1
	fi

	# Determine worktree path
	repo_root=$(git rev-parse --show-toplevel)
	worktree_path="$(dirname "$repo_root")/$worktree_name"

	# Check for existing worktree/path
	if [[ -e "$worktree_path" ]]; then
		echo "Error: path already exists: $worktree_path" >&2
		exit 1
	fi

	if git worktree list --porcelain | grep -q "^worktree.*/$worktree_name$"; then
		echo "Error: worktree '$worktree_name' already exists" >&2
		exit 1
	fi

	# Use current branch if no source specified
	if [[ -z "$source_branch" ]]; then
		source_branch=$(git branch --show-current)
		if [[ -z "$source_branch" ]]; then
			echo "Error: not on any branch and no source branch specified" >&2
			exit 1
		fi
	fi

	# Check if source exists (local/remote branch or tag)
	if git show-ref --verify --quiet "refs/heads/$source_branch" || \
	   git show-ref --verify --quiet "refs/remotes/origin/$source_branch" || \
	   git show-ref --verify --quiet "refs/tags/$source_branch"; then
		# Checkout existing branch/tag
		echo "Creating worktree '$worktree_name' from existing branch/tag '$source_branch'..."
		if error_msg=$(git worktree add "$worktree_path" "$source_branch" 2>&1); then
			echo "Created worktree '$worktree_name' from existing branch/tag '$source_branch'"
		else
			echo "Error: failed to create worktree: $error_msg" >&2
			exit 1
		fi
	else
		# Create new branch
		echo "Creating worktree '$worktree_name' with new branch '$worktree_name'..."
		if error_msg=$(git worktree add -b "$worktree_name" "$worktree_path" "$source_branch" 2>&1); then
			echo "Created worktree '$worktree_name' with new branch '$worktree_name'"
		else
			echo "Error: failed to create worktree with new branch: $error_msg" >&2
			exit 1
		fi
	fi
}

# Removes an existing git worktree
# Args:
#   $1 (worktree_name): Name of the worktree to remove
#   --force: Force removal even if worktree is dirty
# Usage: wt remove <name> [--force]
remove_worktree() {
	local worktree_name=""
	local force=false
	local worktree_path=""

	# Parse arguments
	for arg in "${args[@]:1}"; do
		if [[ "$arg" == "--force" || "$arg" == "-f" ]]; then
			force=true
		elif [[ -z "$worktree_name" ]]; then
			worktree_name="$arg"
		fi
	done

	# Validate worktree name
	if [[ -z "$worktree_name" ]]; then
		echo "Error: worktree name is required" >&2
		echo "Usage: wt remove <worktree-name> [--force]" >&2
		exit 1
	fi

	# Check git repository
	if ! git rev-parse --git-dir &> /dev/null; then
		echo "Error: not in a git repository" >&2
		exit 1
	fi

	# Find worktree path by name
	worktree_path=$(git worktree list --porcelain \
		| awk -v name="$worktree_name" '/^worktree / {
			path = substr($0, 10);
			n = split(path, parts, "/");
			if (parts[n] == name) print path
		}')

	if [[ -z "$worktree_path" ]]; then
		echo "Error: worktree '$worktree_name' not found" >&2
		exit 1
	fi

	# Prevent removing main worktree
	local main_worktree
	main_worktree=$(git worktree list --porcelain | awk '/^worktree / {print substr($0, 10); exit}')
	if [[ "$worktree_path" == "$main_worktree" ]]; then
		echo "Error: cannot remove the main worktree" >&2
		exit 1
	fi

	# Remove the worktree
	local git_args=("worktree" "remove")
	if [[ "$force" == true ]]; then
		git_args+=("--force")
	fi
	git_args+=("$worktree_path")

	echo "Removing worktree '$worktree_name'..."
	if error_msg=$(git "${git_args[@]}" 2>&1); then
		echo "Removed worktree '$worktree_name'"
	else
		echo "Error: failed to remove worktree: $error_msg" >&2
		exit 1
	fi
}

# Displays the help message with usage instructions
# Output: Formatted help text to stdout
help_message() {
	echo -e "wt lets you switch between your git worktrees with speed.\n"
	echo "Usage:"
	echo -e "\twt: go to the main worktree"
	echo -e "\twt <worktree-name>: search for worktree names and change to that directory."
	echo -e "\twt -i: interactively select a worktree using fzf."
	echo -e "\twt list: list out all the git worktrees."
	echo -e "\twt names: list out only the git worktree names."
	echo -e "\twt add <name> [source]: create a new worktree with optional source branch."
	echo -e "\twt remove <name> [--force]: remove an existing worktree."
	echo -e "\twt version: show the CLI version."
	echo -e "\twt init <shell>: print the init script for <shell>."
	echo -e "\twt help: shows this help message."
}

get_dest_path="\$(echo \"\$result\" | awk '/^$CHANGE_DIRECTORY_PREFIX.*/ {sub(\"$CHANGE_DIRECTORY_PREFIX\", \"\"); print; exit}')"

# Generates shell wrapper function for Bash/Zsh
# Output: Shell function code to stdout
init_bash() {
	cat <<EOF
wt() {
	result="\$($BINARY_PATH "\$@")"
	dest_path="$get_dest_path"

	if [[ -n "\$dest_path" ]]; then
		cd "\$dest_path" || return
	elif [[ -n \$result ]]; then
		echo "\$result"
	fi
}
EOF
}

# Generates shell wrapper function for Fish
# Output: Fish function code to stdout
init_fish() {
	cat <<EOF
function wt
	set -l result "\$($BINARY_PATH \$argv)"
	set -l dest_path "$get_dest_path"

	if test -n "\$dest_path"
		cd "\$dest_path"
	else if test -n "\$result"
		echo "\$result"
	end
end
EOF
}

# Outputs shell-specific init script for the requested shell
# Args:
#   $1 (shell): Shell name (bash, zsh, or fish)
# Usage: wt init <shell>
init() {
	shell="${args[1]:-}"
	if [[ -z "$shell" ]]; then
		echo "Please supply a shell."
		echo "    eg. wt init bash"
		exit 1
	fi
	case "$shell" in
	bash|zsh)
		init_bash
		;;
	fish)
		init_fish
		;;
	*)
		echo "Unsupported shell: $shell"
		exit 1
		;;
	esac
}

case "${args[0]}" in
list)
	worktree_list_names
	;;
names)
	worktree_list_names
	echo -e '\033[0;31mThe '\''names'\'' option is deprecated and will be removed in future versions.\033[0m' >&2
	echo -e '\033[0;31mUse '\''list'\'' instead.\033[0m' >&2
	;;
add)
	add_worktree
	;;
remove)
	remove_worktree
	;;
help)
	help_message
	;;
version)
	echo "Version: $VERSION"
	;;
init)
	init
	;;
*)
	# Check if in a git repository
	if ! git rev-parse --git-dir &> /dev/null; then
		echo "Error: not in a git repository" >&2
		exit 1
	fi

	if [[ "$is_interactive" == true ]]; then
		directory=$(git worktree list --porcelain |
		awk '/worktree/ {wt=$2} /branch/ {sub("refs/heads/", "", $2); print wt " [" $2 "]"}' |
		fzf --query "" --height=10% --no-multi --exit-0 |
		awk '{print $1}')
	else
		directory=$(git worktree list --porcelain | grep -E 'worktree ' | awk '/'"$arg"'/ {print; exit}' | cut -d ' ' -f2-)
	fi

	;;
esac

# If directory variable is not empty then change worktree
if [[ -n "${directory:-}" ]]; then
	echo "$CHANGE_DIRECTORY_PREFIX$directory"
elif [[ -n "${args[0]:-}" && "${args[0]}" != "-i" && "${args[0]}" != "list" && "${args[0]}" != "names" && "${args[0]}" != "add" && "${args[0]}" != "remove" && "${args[0]}" != "help" && "${args[0]}" != "version" && "${args[0]}" != "init" ]]; then
	echo "Error: worktree '${args[0]}' not found" >&2
	exit 1
fi
